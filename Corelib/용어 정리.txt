Ref<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Ref>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

COM(Component Object Model<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

COM? 개체들이 다른 개체와 통신하고 기능을 필요로 하는 다른 개체에게 자신의 기능을 제공

특징 : 설계된 다음에는 변경되지 않는다. -> 다른 요소에 상관없이 업데이트 및 향상 가능.
각각의 COM 컴포넌트들은 클래스 아이디(CLSIDs)로 식별 
컴포넌트의 "기능"은 하나 이상의 "인터페이스"를 통해 외부로 노출된다.
인터페이스는 인터페이스 아이디(IIDs)로 식별된다.
CLSIDs, IIDs는 GUID형식으로 되어있다.

규칙 : 외부로 IUnknown "인터페이스"를 노출하고 QueryInterface() 맴버함수를 이용하여 생성된
인터페이스를 반환 받는 방식 소멸 역시 Release()맴버함수를 사용
QueryInterface()를 사용시 AddRef()에 의해 참조 카운팅 1 증가.
Release() 함수의 호출로 참조카운팅 1 감소.
참조카운트가 0이 되면 메모리를 해제하게 된다.

@* 컴포넌트 소프트웨어 : 전체 시스템과 통신을 유지하면서 시스템의 다른 구성 요소와 독립적으로
작동하는 별도의 모듈 또는 프로그래밍 개체
@* 모듈 : 대규모의 소프트웨어 프로그램의 구성요소를 관리 가능한 부분으로 분리한 것.
@* GUID : 요청마다 고유 ID가 생성 되도록하는 알고리즘. MAC주소를 사용한다.
		Windows 운영체제 내에선 운영체제의 특수 기능을 통해 생성되며 특정 하드웨어 구성 내에서
		고유 id가 보장 된다.
		여러 하드웨어 서버에서 사용할 수 있는 guid를 만들려면 하드웨어 운영체제 내에서 특별 식별자 사용
		일부는 ip주소 조합이 포함된 타임 스탬프를 사용하기도 한다.
COM(Component Object Model>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Resource <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
ID3D11Resource클래스에서 파생된 모든 리소스

버퍼(정점버퍼 인덱스버퍼 상수버퍼)와 텍스쳐(1D 2D 3D 큐브)등을 하나로 관리하기 위해
ID3D11Resource는 부모 클래스로서 사용된다.

IUnknown -> ID3D11DeviceChile -> ID3D11Resource -> 각종 버퍼들
이와 같이 부모 상속관계가 형성되어 있다.

*ID3D11Resource->GetDesc(&D3D11_RESOURCE_DESC) 을 통해서 리소스의 자세한 정보를 얻을 수 있다.

서브리소스는 lod를 사용하여 그 하위 단계에 대한 정보를 가진것

  배열슬라이스 : 한개의 이미지에 서브리소스까지 다 포함한것
  밉맵 슬라이스 : 모든 텍스쳐에서 같은 level의 모든밉맵 정보를 가진것

  UpdateSubresoure : 파이프라인에서 쓰이는 리소스의 매개변수가 변경 내역이 있을 경우 바꿀 수 있다.
  1. CreateBuffer로 만든 버텍스의 좌표변경에 대해 바꿀 수 있다.
    -> 보통 프레임에서 오브젝트의 이동을 표현함
  2. CreateTexture2D로 만든 택스쳐 이미지의 정보를 UpdateSubresource로 변경 가능.
  

Resource >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Start Resource View<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Resource View			: Resource를 파이프라인에 묶는다.
_1 Resource View를 이용할 자원 
_2 Desc
_3 해당 Resouce에 대한 포인터

1. RenderTargetView		: 출력 대상을 파이프라인에 묶는다. 색상값 정보.
2. DepthStencilView		: 출력 대상을 파이프라인에 묶는다. 깊이, 스텐실 정보.
3. ShaderResourceView	: 파이프 라인의 프로그램 가능 셰이더 단계가 자원을 읽을
			수 있게 한다. 이 뷰는 예전 PS에서 텍스쳐가 하던 역할. 
			즉, 셰이더 프로그램 안에서	읽고 사용할 수는 있지만 기록하지는 못하는 자료
4. UnorderedAccessView	:셰이더 프로그램 안에서 자원을 읽음과 동시에 쓰기도 할 수 있다.
게다가, 출력 장소가 미리 정해져 있지 않기 때문에 셰이더 프로그램 안에서 자원 안의
임의의 위치에 scatter 연산을 수행 하는 것도 가능하다.

@* RenderTarget : 다음 프레임의 메모리 영역 (= 백버퍼)
@* 레스터화 : 벡터 형식 ->  픽셀, 점과 같이 표현
@* 스텐실 : 다른 효과를 얻거나 장면을 마스크 처리

End Resource View>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Sampler<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
샘플러의 역할
1. 컬링 : uv가 1이 넘어갈 때 절단.
2. 이미지 스케일 조절
	MIN(Minification)	축소
	MAG(Magnification)	확대
	MIP-mapping			밉맵
	밉맵 : 2의 n제곱 크기의 이미지를 만들어 거리에 따라 다른 크기의 이미지를 보여준다.
	513 크기의 이미지라면 가까울땐 512 256 128 64 순서대로 이미지 크기를 조절한다.
	현재 컴퓨터의 성능 향상으로 잘 사용하지 않음.
3. 2Pass 연산 (펄업)
	포인트 샘플링(Point) : 크기 조절시 인접 픽셀의 색상 값을 그대로 가져다 씀.
	선형 필터링 (Linear) : 크기 조절시 인접 픽셀의 평균값을 얻음
	비 등방성(Anistorpic) : 안티 엘리어싱, 샘플링에서 샘플링 주파수가 원본 주파수보다 2배이상 낮은 경우
		발생하는 계단 현상 왜곡
4. Lod설정

5. hlsl SamplerState와 구분짓자.
Sampler>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

SV<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
System Velue의 약자

은 Blob을 이용하여 CreateInputLayout()을 통해 만들어지며
IASetInputLayout에서 해당 시맨틱 정의를 사용하겠다는 걸 파이프라인에 바인딩 할 수있다.
그러나 SV_가 접두어로 붙은 시맨틱은 내가 설정하는 것이 아니다.
이미 정의 되어 있다. hlsl과 DirectX에서 이미 정의되어 있다. 
dx10부터 지원.
vs_4 부터 지원
https://mgun.tistory.com/1848
SV>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

hlsl::사전 정의 타입<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
Texture2D shaderTexture; // 쉐이더 리소스 뷰? 이거 확실치않음 중요한건 .sample함수를 맴버로 가짐
	// 해당 함수의 좌표에 픽셀을 선택해서 반환해주는 함수
	.sample(SamplerState, 픽셀을 저장할 좌표float) 
// 텍스쳐에서 가지고온 픽셀을 픽셀 셰이더에서 작업해주는 구조체 오히려 이놈이 텍스쳐 정보를 갖고있을듯.
SamplerState SampleType; 

typedef로 struct구조체의 이름을 바꾸는 것도 가능하다
typedef VS_OUTPUT PS_INPUT;
hlsl::사전 정의 타입>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

hlsl::사전 정의 시맨틱<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
SV_ : System Velue의 약자로 shader _4.0부터 지원
register(t0) : 0~15까지 지정가능하며 dc->Resource(startSlot,)에 해당하는 번호임

sv_position : 픽셀로 사용될 버텍스
sv_target : 어떤 랜더 타켓으로 반환할 지

hlsl::사전 정의 시맨틱>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

hlsl::SamplerState<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
필터링 : 화면의 확대와 축소 픽셀 값의 조정
확대 필터링, 축소 필터링
hlsl::SamplerState>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

hlsl::알파테스팅<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
if (final.a < 0.5f)
{
	discard;
}
위와 같이 사용한다
해당되는 픽셀을 버린다.
z버퍼를 기입을 하지 않는다
단, a값이 0 or 1 일때만 사용 가능. 완전 투명 or 완전 불투명
주로 식물의 나뭇잎과 같은 경우에 사용됨
따라서 색이 섞여야하는 경우는 알파 블랜딩을 사용하자

용도 
순서를 구분하기 어려운 오브젝트 랜더링시 정렬된 상태와 유사하게 랜더링 된다.
hlsl::알파테스팅>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
